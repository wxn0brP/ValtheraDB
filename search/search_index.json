{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ValtheraDB: Your Data, Your Rules","text":"<p>Welcome to ValtheraDB \u2013 a modular, embedded database for developers who want to build their perfect data layer. With a familiar API and unparalleled flexibility, ValtheraDB empowers you to take control of your data storage.</p>"},{"location":"#our-philosophy-control-and-flexibility","title":"Our Philosophy: Control and Flexibility","text":"<p>In a world of one-size-fits-all solutions, ValtheraDB is different. We believe that you, the developer, should have the final say on how your data is managed. Our core philosophy is built on two pillars:</p> <ul> <li>Unmatched Modularity: The storage engine is just a plugin. Don't like JSON files? Use a single binary file, YAML, <code>localStorage</code>, or invent your own format. ValtheraDB's architecture is designed to adapt to your needs, not the other way around.</li> <li>Pragmatic Power: We provide powerful features like cross-database relations and a rich query API, but we keep it simple. ValtheraDB is designed for small to medium-sized applications where a custom-fit and developer experience are more important than supporting massive datasets.</li> </ul>"},{"location":"#who-is-valtheradb-for","title":"Who is ValtheraDB for?","text":"<p>ValtheraDB is a great fit if you are:</p> <ul> <li>A Node.js or Bun developer building a backend and wanting an easy-to-use, embedded database without the overhead of a separate database server.</li> <li>A frontend developer creating a Progressive Web App (PWA) that needs offline capabilities or complex client-side storage.</li> <li>An Electron developer who needs a straightforward way to store data locally in a desktop application.</li> <li>A creative coder who wants to experiment with unconventional storage methods for your projects.</li> </ul> <p>In short, if you value flexibility and control over rigid conventions, you'll feel right at home.</p>"},{"location":"#key-features-at-a-glance","title":"Key Features at a Glance","text":"<ul> <li>\ud83e\uddf1 Pluggable Storage Engine: Bring your own storage adapter.</li> <li>\ud83e\udd1d Powerful Cross-Database Relations: Create relationships between data across entirely separate database instances.</li> <li>\ud83e\udde0 Familiar MongoDB-like API: Start working quickly with an intuitive and expressive query language.</li> <li>\ud83c\udf10 Runs Everywhere: Optimized for Bun, great with Node.js, and fully capable in the browser.</li> <li>\ud83d\ude80 Client-Server Ready: Scale from an embedded solution to a client-server architecture when you need to.</li> <li>\ud83d\udeab Zero Configuration: Point it to a directory, and you're good to go.</li> </ul>"},{"location":"#where-to-go-next","title":"Where to Go Next?","text":"<ul> <li>Getting Started: Jump into our hands-on tutorial and build your first application with ValtheraDB.</li> <li>Core Concepts: Learn about the fundamental ideas that make ValtheraDB unique.</li> <li>API Reference:<ul> <li>Collection</li> <li>Valthera Class</li> <li>Relations</li> <li>Search Operators</li> <li>Update Operators</li> <li>Find Options</li> <li>Remote</li> </ul> </li> </ul>"},{"location":"collection/","title":"Collection Class Documentation","text":"<p>This documentation provides a detailed overview of the <code>Collection</code> class, designed for performing CRUD operations on Valthera collections.</p>"},{"location":"collection/#class-collectiont-extends-object-data","title":"Class: <code>Collection&lt;T extends object = Data&gt;</code>","text":""},{"location":"collection/#usage","title":"Usage:","text":"<pre><code>const db = ValtheraCreate(\"db\");\nconst users = db.c(\"users\");\n</code></pre>"},{"location":"collection/#async-addcollection-data-id_gentrue","title":"<code>async add(collection, data, id_gen=true)</code>","text":"<p>Adds data to a specified collection.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>data</code> (<code>Object</code>): The data to add.</li> <li> <p><code>id_gen</code> (<code>boolean</code>, default: true): Whether to generate an ID for the entry.</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T &amp; { _id: string }&gt;</code>: If <code>id_gen</code> is true, a promise that resolves with the added data including a generated <code>_id</code>.</li> <li><code>Promise&lt;T&gt;</code>: If <code>id_gen</code> is false, a promise that resolves with the added data.</li> </ul>"},{"location":"collection/#async-findcollection-search-dbfindopts-findopts-context","title":"<code>async find(collection, search, dbFindOpts, findOpts, context)</code>","text":"<p>Finds data in a collection based on a query.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>, optional): The search query.</li> <li><code>dbFindOpts</code> (<code>Object</code>, optional): Search options (e.g., <code>max</code>, <code>reverse</code>).</li> <li><code>findOpts</code> (<code>Object</code>, optional): Options for updating the search result.</li> <li> <p><code>context</code> (<code>Object</code>, optional): The context object (for functions).</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T[]&gt;</code>: Found data. Empty array if no match is found.</li> </ul>"},{"location":"collection/#async-findonecollection-search-findopts-context","title":"<code>async findOne(collection, search, findOpts, context)</code>","text":"<p>Finds one matching entry in a collection.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>, optional): The search query.</li> <li><code>findOpts</code> (<code>Object</code>, optional): Options for updating the search result.</li> <li> <p><code>context</code> (<code>Object</code>, optional): The context object (for functions).</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T|null&gt;</code>: Found data. Null if no match is found.</li> </ul>"},{"location":"collection/#async-updatecollection-search-updater-context","title":"<code>async update(collection, search, updater, context)</code>","text":"<p>Updates data in a collection.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>): The search query.</li> <li><code>updater</code> (<code>function|Object</code>): Update arguments.</li> <li> <p><code>context</code> (<code>Object</code>, optional): The context object (for functions).</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T[] | null&gt;</code>: Updated data. Null if no match is found.</li> </ul>"},{"location":"collection/#async-updateonecollection-search-updater-context","title":"<code>async updateOne(collection, search, updater, context)</code>","text":"<p>Updates one entry in a collection.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>): The search query.</li> <li><code>updater</code> (<code>function|Object</code>): Update arguments.</li> <li> <p><code>context</code> (<code>Object</code>, optional): The context object (for functions).</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T | null&gt;</code>: Updated data. Null if no match is found.</li> </ul>"},{"location":"collection/#async-updateoneoraddcollection-search-updater-options","title":"<code>async updateOneOrAdd(collection, search, updater, options)</code>","text":"<p>Updates one entry or adds a new one if it doesn't exist.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>): The search query.</li> <li><code>updater</code> (<code>function|Object</code>): Update arguments.</li> <li> <p><code>options</code> (<code>Object</code>, optional): An object containing <code>add_arg</code>, <code>context</code>, and <code>id_gen</code>.</p> <ul> <li><code>add_arg</code> (<code>Object</code>): Data to add if no match is found.</li> <li><code>context</code> (<code>Object</code>): The context object (for functions).</li> <li><code>id_gen</code> (<code>boolean</code>, default: true): Whether to generate an ID for the new entry.</li> </ul> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T&gt;</code>: A promise that resolves with the updated or added entry.</li> </ul>"},{"location":"collection/#async-toggleonecollection-search-data-context","title":"<code>async toggleOne(collection, search, data, context)</code>","text":"<p>Asynchronously updates one entry in a database or adds a new one if it doesn't exist. Usage e.g. for toggling a flag.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>): The search query.</li> <li><code>data</code> (<code>Object</code>, optional): The data to use.</li> <li> <p><code>context</code> (<code>Object</code>, optional): The context object (for functions).</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T | null&gt;</code>: T when added, null when removed.</li> </ul>"},{"location":"collection/#async-removecollection-search-context","title":"<code>async remove(collection, search, context)</code>","text":"<p>Removes data from a collection.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>): The search query.</li> <li> <p><code>context</code> (<code>Object</code>, optional): The context object (for functions).</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T[] | null&gt;</code>: Removed data. Null if no match is found.</li> </ul>"},{"location":"collection/#async-removeonecollection-search-context","title":"<code>async removeOne(collection, search, context)</code>","text":"<p>Removes one entry from a collection.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li><code>search</code> (<code>function|Object</code>): The search query.</li> <li> <p><code>context</code> (<code>Object</code>, optional): The context object (for functions).</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;T | null&gt;</code>: Removed data. Null if no match is found.</li> </ul>"},{"location":"core_concepts/","title":"ValtheraDB Idea: A Database That Thinks Like a Developer","text":"<p>Welcome to the world of ValtheraDB \u2013 a project born from a simple conviction: a database should adapt to your programming style, not the other way around.</p> <p>Instead of yet another implementation of rigid paradigms, we created a flexible environment that understands the real challenges of modern applications. It is not just a tool for storing data \u2013 it is a philosophy of software development.</p>"},{"location":"core_concepts/#pluggable-storage-paradigm-your-vision-your-medium","title":"Pluggable Storage Paradigm: Your Vision, Your Medium","text":""},{"location":"core_concepts/#the-ideas-behind-the-concept","title":"The ideas behind the concept","text":"<p>In traditional databases, form determines substance \u2013 the choice of SQL vs NoSQL, local files vs server, defines the architecture of the entire application. ValtheraDB reverses this logic.</p> <p>The central idea: separating data logic from physical storage. Your code operates on objects and relationships, while the method of persistence is a replaceable module.</p>"},{"location":"core_concepts/#why-is-this-important","title":"Why is this important?","text":"<ol> <li>Evolution without revolution    Start with JSON files during prototyping. Move to IndexedDB for PWAs. End up with a remote server in production. All with the same business logic.</li> <li>A natural language for data    You do not think in \"tables\", \"documents\", or \"graphs\". You think in \"users\", \"orders\", \"events\". ValtheraDB speaks your language.</li> <li>Architecture without compromise    Every application has unique requirements. ValtheraDB lets you choose the optimal solution without sacrificing developer convenience.</li> </ol>"},{"location":"core_concepts/#metaphor-file-system-vs-cloud","title":"Metaphor: File system vs cloud","text":"<p>Just as a file browser works the same for local disks and Dropbox, ValtheraDB provides a unified API regardless of backend. It is abstraction that truly abstracts.</p>"},{"location":"core_concepts/#relation-engine-unity-in-diversity","title":"Relation Engine: Unity in Diversity","text":""},{"location":"core_concepts/#the-problem-we-are-solving","title":"The problem we are solving","text":"<p>Modern applications are ecosystems \u2013 microservices, modules, separate databases for different functions. Traditional databases force a choice: either a monolith (everything in one DB) or chaos (manually gluing distributed data).</p> <p>ValtheraDB proposes a third path: autonomous, yet connected data collections.</p>"},{"location":"core_concepts/#the-philosophy-of-relationships","title":"The philosophy of relationships","text":"<ol> <li>Declarativity over imperativity    Instead of writing algorithms for data joins, you describe relationships between them. The system executes your intent.</li> <li>Context preserved    Data remains in its natural environment (logs in a separate store, users in the main one), but forms a coherent whole during queries.</li> <li>Semantics over syntax    It does not matter how the data is stored \u2013 what matters is what it means and how it connects.</li> </ol>"},{"location":"core_concepts/#example-in-action","title":"Example in action","text":"<p>Imagine an e-commerce application:</p> <ul> <li>Main database: products, users</li> <li>Separate database: reviews (frequent updates)</li> <li>Another database: analytics logs</li> </ul> <p>In the traditional approach \u2013 three different queries, manual mapping. In ValtheraDB \u2013 one query combines everything as if it lived in one place.</p>"},{"location":"core_concepts/#principle-of-symmetry-the-same-code-every-platform","title":"Principle of Symmetry: The Same Code, Every Platform","text":""},{"location":"core_concepts/#unified-experience","title":"Unified experience","text":"<p>ValtheraDB stems from a simple observation: developers write business logic, not storage implementations. Therefore, we provide:</p> <ol> <li>Environment isomorphism    The same code runs in Node.js, the browser, and Electron. No conditional imports, no polyfills.</li> <li>Progressive specialization    Start with the simplest configuration (JSON files). Move to the advanced one (remote server) without changing a line of application code.</li> <li>Expressiveness without complexity    Powerful capabilities through a simple API. Complex inside, simple outside.</li> </ol>"},{"location":"core_concepts/#security-by-design-protecting-against-nosql-injection","title":"Security by Design: Protecting Against NoSQL Injection","text":"<p>ValtheraDB prioritizes security, particularly against common vulnerabilities like NoSQL injection. A key design principle that contributes to this security is the strict handling of root-level operators.</p> <p>It is crucial to understand that the treatment of root-level operators as an internal, controlled feature, rather than a user-promotable one, is a deliberate design choice, not a limitation. This approach inherently protects applications by preventing malicious users from elevating data input into query operators. By disallowing users from introducing or overriding operators within their input, ValtheraDB effectively mitigates the risk of query manipulation, ensuring that data operations remain within the defined scope and intent of the application developer. This means you can build with confidence, knowing that your queries are safeguarded from unauthorized alterations through data input.</p>"},{"location":"core_concepts/#valtheradb-in-the-developer-ecosystem","title":"ValtheraDB in the Developer Ecosystem","text":""},{"location":"core_concepts/#who-is-this-database-for","title":"Who is this database for?","text":"<ol> <li>PWA creators    They want consistent online/offline experience without the burden of IndexedDB API.</li> <li>Microservices architects    They need flexible data linking across multiple sources.</li> <li>Experimenters and prototypes    They value speed of iteration over premature optimization.</li> <li>Educators    They seek a system that teaches concepts, not the syntax of a specific technology.</li> </ol>"},{"location":"core_concepts/#philosophy-in-practice","title":"Philosophy in practice","text":"<p>ValtheraDB does not compete with PostgreSQL or MongoDB in their niches. It offers a third space \u2013 where what matters is not petabyte performance, but the joy of development.</p> <p>It is a database that:</p> <ul> <li>Remembers that you are building an application, not managing data</li> <li>Understands that projects evolve from MVP to scalable solutions</li> <li>Respects that each environment (backend, frontend, desktop) has its own constraints</li> </ul>"},{"location":"core_concepts/#summary-a-database-as-a-collaborator","title":"Summary: A Database as a Collaborator","text":"<p>ValtheraDB is more than a tool \u2013 it is a partner in the software creation process. It does not impose limitations but offers possibilities. It does not complicate simple tasks but enables advanced scenarios.</p> <p>In a world dominated by \"one size fits all\", ValtheraDB is a rebellion: the developer knows best what is right for their application. We simply provide the capabilities \u2013 you decide how to use them.</p> <p>It is a database that does not ask \"why do you want to do this?\", but \"how can I help you do it?\"</p> <p>Ready to build software according to your vision, not the limitations of tools? Begin your journey with a database that thinks the way you do.</p>"},{"location":"find_opts/","title":"Find Options","text":""},{"location":"find_opts/#predefined-find-options-quick-reference-post-data-matching-processing","title":"Predefined Find Options Quick Reference (Post Data-Matching Processing)","text":""},{"location":"find_opts/#description","title":"Description","text":"<p>These options are applied as part of a post-processing step after matching objects are found in the database (<code>find</code> stage) but before the data is returned to the client. This process is designed to: 1. Reduce data transfer size by removing unnecessary fields or selecting only the required ones. 2. Customize results by transforming objects to meet specific requirements.  </p> <p>This optimization improves both performance and result usability, ensuring the client receives precisely the needed data in a compact form.</p>"},{"location":"find_opts/#execution-stack","title":"Execution Stack","text":"<ol> <li><code>transform</code></li> <li><code>exclude</code></li> <li><code>select</code></li> </ol>"},{"location":"find_opts/#operators","title":"Operators","text":""},{"location":"find_opts/#select","title":"<code>select</code>","text":"<p>Selects only specific fields to include in the final object.</p> <pre><code>// Original Object\n{\n    name: \"John Doe\",\n    email: \"john@example.com\",\n    age: 30,\n    status: \"active\"\n}\n\n// Find Options\n{\n    select: [\"name\", \"email\"]\n}\n\n// Result\n{\n    name: \"John Doe\",\n    email: \"john@example.com\"\n}\n</code></pre>"},{"location":"find_opts/#exclude","title":"<code>exclude</code>","text":"<p>Excludes specific fields from the object, removing unwanted data.</p> <pre><code>// Original Object\n{\n    name: \"John Doe\",\n    email: \"john@example.com\",\n    age: 30,\n    status: \"active\"\n}\n\n// Find Options\n{\n    exclude: [\"name\"]\n}\n\n// Result\n{\n    email: \"john@example.com\",\n    age: 30,\n    status: \"active\"\n}\n</code></pre>"},{"location":"find_opts/#transform","title":"<code>transform</code>","text":"<p>Applies a custom updater function to modify the object.</p> <pre><code>// Original Object\n{\n    name: \"John Doe\",\n    email: \"john@example.com\",\n    age: 30,\n    status: \"active\"\n}\n\n// Find Options\n{\n    transform: (doc) =&gt; {\n        doc.name = doc.name.toUpperCase();\n        return doc;\n    }\n}\n\n// Result\n{\n    name: \"JOHN DOE\",\n    email: \"john@example.com\",\n    age: 30,\n    status: \"active\"\n}\n</code></pre>"},{"location":"find_opts/#combined-example","title":"Combined Example","text":"<p>Using all operators together to demonstrate the execution stack.</p> <pre><code>// Original Object\n{\n    name: \"John Doe\",\n    email: \"john@example.com\",\n    age: 30,\n    status: \"active\"\n}\n\n// Find Options\n{\n    transform: (doc) =&gt; {\n        doc.newField = \"added\";\n        doc.status = \"inactive\";\n        return doc;\n    },\n    exclude: [\"email\", \"newField\"],\n    select: [\"name\", \"status\"]\n}\n\n// Execution Steps:\n1. transform:\n   {\n       name: \"John Doe\",\n       email: \"john@example.com\",\n       age: 30,\n       status: \"inactive\",\n       newField: \"added\"\n   }\n2. exclude:\n   {\n       name: \"John Doe\",\n       age: 30,\n       status: \"inactive\"\n   }\n3. select:\n   {\n       name: \"John Doe\",\n       status: \"inactive\"\n   }\n\n// Final Result:\n{\n    name: \"John Doe\",\n    status: \"inactive\"\n}\n</code></pre> <p>This structured flow ensures flexible and predictable results, making it a powerful tool for refining and manipulating data.</p>"},{"location":"getting_started/","title":"Getting Started: Building a Mini-Blog","text":"<p>Welcome to ValtheraDB! This guide will walk you through the entire process of building a simple application-a mini-blog-to demonstrate how to get up and running quickly. We'll cover everything from installation to using powerful features like relations.</p> <p>By the end of this tutorial, you will have learned how to:</p> <ul> <li>Install ValtheraDB</li> <li>Create a database and collections</li> <li>Add and query for data</li> <li>Link related data together</li> </ul>"},{"location":"getting_started/#step-1-installation","title":"Step 1: Installation","text":"<p>First things first, let's add ValtheraDB to your project. Open your terminal and run the following command:</p> <pre><code># Using npm\nnpm install @wxn0brp/db\n\n# Or using yarn\nyarn add @wxn0brp/db\n\n# Or using bun\nbun add @wxn0brp/db\n</code></pre> <p>Now you're ready to start using it in your code.</p>"},{"location":"getting_started/#step-2-setting-up-the-database","title":"Step 2: Setting Up the Database","text":"<p>ValtheraDB is an embedded database, which means it runs directly within your application. To get started, you just need to point it to a directory where it can store its data.</p> <p>Let's create our database instance.</p> <pre><code>import { ValtheraCreate } from \"@wxn0brp/db\";\n\n// Create a new database instance inside the \"./my-blog-db\" directory\nconst db = ValtheraCreate&lt;{\n  // Define your collections here (for type checking)\n  users: {\n    name: string;\n    email: string;\n    _id: string;\n  };\n  posts: {\n    title: string;\n    content: string;\n    authorId: string;\n    _id: string;\n  };\n}&gt;(\"./my-blog-db\");\n</code></pre> <p>If you run this code, a new folder named <code>my-blog-db</code> will be created in your project. This is where all your collections and documents will live. It's that simple!</p>"},{"location":"getting_started/#step-3-adding-your-first-user","title":"Step 3: Adding Your First User","text":"<p>Our blog will have authors, so let's create a <code>users</code> collection and add our first author to it. A \"collection\" is just a group of similar documents, like a table in a SQL database.</p> <p>The <code>db.add()</code> method adds a new document to a specified collection and automatically generates a unique <code>_id</code> for it.</p> <pre><code>async function setup() {\n  // Add a new document to the \"users\" collection\n  const author = await db.users.add({\n    name: \"Jane Doe\",\n    email: \"jane.doe@example.com\"\n  });\n\n  console.log(\"Successfully added author:\", author);\n  // Expected output:\n  // Successfully added author: { name: 'Jane Doe', email: 'jane.doe@example.com', _id: '...' }\n}\n\nsetup();\n</code></pre>"},{"location":"getting_started/#step-4-adding-posts-for-our-user","title":"Step 4: Adding Posts for Our User","text":"<p>Now that we have an author, let's give them something to write. We'll create a <code>posts</code> collection. To link a post to its author, we'll add an <code>authorId</code> field to our post documents, storing the <code>_id</code> of the user we just created.</p> <pre><code>async function setup() {\n  // First, find our author to get their ID\n  const author = await db.users.findOne({ email: \"jane.doe@example.com\" });\n\n  if (!author) {\n    console.log(\"Author not found!\");\n    return;\n  }\n\n  // Now, create the \"posts\" collection\n  const posts = db.posts;\n\n  // Next, add a couple of posts linked to the author\n  const post1 = await posts.add({\n    title: \"My First Post\",\n    content: \"This is the content of my first post.\",\n    authorId: author._id // Link to the author\n  });\n\n  const post2 = await posts.add({\n    title: \"Advanced Concepts\",\n    content: \"Exploring the depths of ValtheraDB.\",\n    authorId: author._id // Link to the same author\n  });\n\n  console.log(\"Added posts:\", post1, post2);\n}\n\nsetup();\n</code></pre> <p>Here we used <code>db.findOne()</code> to retrieve a single document that matches our query. It's a quick way to find a specific entry.</p>"},{"location":"getting_started/#step-5-updating-data","title":"Step 5: Updating Data","text":"<p>Sometimes, data changes! ValtheraDB provides easy ways to update existing documents. Let's say Jane Doe decided to update her email address. We can use <code>db.updateOne()</code> to modify her user record.</p> <pre><code>async function updateAuthor() {\n  const users = db.users;\n  const updated = await users.updateOne(\n    { name: \"Jane Doe\" }, // Find Jane Doe\n    { email: \"jane.d.new@example.com\" } // Update her email\n  );\n\n  if (updated) {\n    console.log(\"Author's email updated successfully!\");\n  } else {\n    console.log(\"Author not found or no changes made.\");\n  }\n\n  // Verify the update\n  const jane = await users.findOne({ name: \"Jane Doe\" });\n  console.log(\"Updated Jane Doe:\", jane);\n}\n\nupdateAuthor();\n</code></pre> <p>The <code>db.updateOne()</code> method takes a search query and an updater object. It finds the first document matching the query and applies the updates. For more complex updates (like incrementing numbers or manipulating arrays), you can use Updater Operators.</p>"},{"location":"getting_started/#step-6-updating-or-adding-upsert","title":"Step 6: Updating or Adding (Upsert)","text":"<p>Sometimes you need to ensure that a piece of data exists: updating it if it's already there or creating it if it's new. This is a common pattern known as \"upsert\", and ValtheraDB supports it with <code>db.updateOneOrAdd()</code>.</p> <p>Let's try to update a post. If the post with a specific title exists, we'll update its content. If not, we'll add it as a new post.</p> <pre><code>async function upsertPost() {\n  // First, get the author's ID for linking new posts\n  const author = await db.users.findOne({ email: \"jane.d.new@example.com\" });\n  if (!author) {\n    console.error(\"Author not found for upsert operation.\");\n    return;\n  }\n\n  const posts = db.posts;\n\n  // Scenario 1: Update an existing post\n  const updatedExisting = await posts.updateOneOrAdd(\n    { title: \"My First Post\" }, // Search for this post\n    { content: \"This is the *updated* content of my first post.\" } // Update its content\n  );\n  console.log(\"Updated existing post?\", updatedExisting);\n\n  // Scenario 2: Add a new post if it doesn't exist\n  const addedNew = await posts.updateOneOrAdd(\n    { title: \"A Brand New Post\" }, // Search for this post (it won't exist yet)\n    {\n      content: \"This post was created using updateOneOrAdd.\",\n    }, // Data to update/add\n    { \n      add_arg: {\n        authorId: author._id\n      } // Data to add if new\n    }\n  );\n  console.log(\"Added new post?\", addedNew);\n\n  // Verify the changes\n  const userPosts = await posts.find({ authorId: author._id });\n  console.log(\"All posts after upsert:\", userPosts);\n}\n\nupsertPost();\n</code></pre> <p><code>db.updateOneOrAdd()</code> is incredibly flexible. The <code>add_arg</code> option allows you to specify additional data to be merged when a new document is created.</p>"},{"location":"getting_started/#step-7-bringing-it-all-together-with-relations","title":"Step 7: Bringing It All Together with Relations","text":"<p>We now have users and posts, but they are in separate collections. How do we retrieve a user and all their posts in a single query? This is where ValtheraDB's <code>Relation</code> engine shines.</p> <p>Relations allow you to define relationships between your collections and fetch linked data effortlessly.</p> <p>Let's find our author and embed all of their posts directly into the result.</p> <pre><code>async function findUserWithPosts() {\n  // 1. The Relation class needs an object mapping names to database instances.\n  const dbs = {\n    main: db,\n  };\n\n  // 2. Define the relationship.\n  // We're creating a relation named \"posts\".\n  const relations: RelationTypes.Relation = {\n    posts: {\n      // It finds data in the \"posts\" collection of the \"main\" db.\n      path: [\"main\", \"posts\"],\n      // It's a \"one-to-many\" relationship.\n      type: \"1n\",\n      // It matches documents where the \"authorId\" in the \"posts\" collection...\n      fk: \"authorId\",\n      // ...is equal to the \"_id\" in the \"users\" collection.\n      pk: \"_id\"\n    },\n  };\n\n  // 3. Create a new Relation instance.\n  const relation = new Relation(dbs);\n\n  // 4. Find the user and apply the relations.\n  const authorWithPosts = await relation.findOne(\n    [\"main\", \"users\"], // The collection we are querying\n    { name: \"Jane Doe\" }, // The user we are looking for\n    relations // The relations to apply\n  );\n\n  console.dir(authorWithPosts, { depth: null });\n}\n\nfindUserWithPosts();\n</code></pre> <p>The <code>console.dir</code> output will show you the user object with a new <code>posts</code> array field containing the full documents of both posts we created.</p> <pre><code>{\n  \"name\": \"Jane Doe\",\n  \"email\": \"jane.d.new@example.com\",\n  \"_id\": \"...\",\n  \"posts\": [\n    {\n      \"title\": \"My First Post\",\n      \"content\": \"This is the content of my first post.\",\n      \"authorId\": \"...\",\n      \"_id\": \"...\"\n    },\n    {\n      \"title\": \"Advanced Concepts\",\n      \"content\": \"Exploring the depths of ValtheraDB.\",\n      \"authorId\": \"...\",\n      \"_id\": \"...\"\n    }\n    // ...\n  ]\n}\n</code></pre>"},{"location":"getting_started/#whats-next","title":"What's Next?","text":"<p>Congratulations! You've just scratched the surface of what ValtheraDB can do.</p> <ul> <li>Ready to learn about the fundamental ideas behind ValtheraDB? Dive into our Core Concepts page.</li> <li>Want to see all the powerful ways you can query your data? Check out the Search Options.</li> <li>Curious about how to perform complex data updates? Read the Updater documentation.</li> </ul>"},{"location":"relation/","title":"Relation Class Documentation","text":"<p>The <code>Relation</code> class provides a mechanism to handle relationships between collections in a database. It supports one-to-one, one-to-many, and many-to-many relationships.</p>"},{"location":"relation/#class-relation","title":"Class: <code>Relation</code>","text":""},{"location":"relation/#constructor-relationdbs","title":"Constructor: <code>Relation(dbs)</code>","text":"<p>Creates a new instance of the <code>Relation</code> class.</p> <ul> <li>Parameters:</li> <li><code>dbs</code> (<code>RelationTypes.DBS</code>): An object mapping database names to <code>DataBase</code> or <code>DataBaseRemote</code> instances.</li> </ul>"},{"location":"relation/#async-findonepath-search-relations-select","title":"<code>async findOne(path, search, relations, select?)</code>","text":"<p>Finds a single entry in a collection and resolves its relations.</p> <ul> <li>Parameters:</li> <li><code>path</code> (<code>RelationTypes.Path</code>): A tuple specifying the database and collection.</li> <li><code>search</code> (<code>Search</code>): The search criteria.</li> <li><code>relations</code> (<code>RelationTypes.Relation</code>): The relations to resolve.</li> <li> <p><code>select</code> (<code>RelationTypes.FieldPath[]</code>, optional): Fields to select in the result.</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;Object | null&gt;</code>: The found entry with resolved relations, or <code>null</code> if no match is found.</li> </ul>"},{"location":"relation/#async-findpath-search-relations-select-findopts","title":"<code>async find(path, search, relations, select?, findOpts?)</code>","text":"<p>Finds multiple entries in a collection and resolves their relations.</p> <ul> <li>Parameters:</li> <li><code>path</code> (<code>RelationTypes.Path</code>): A tuple specifying the database and collection.</li> <li><code>search</code> (<code>Search</code>): The search criteria.</li> <li><code>relations</code> (<code>RelationTypes.Relation</code>): The relations to resolve.</li> <li><code>select</code> (<code>RelationTypes.FieldPath[]</code>, optional): Fields to select in the results.</li> <li> <p><code>findOpts</code> (<code>DbFindOpts</code>, optional): Options for the find operation.</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;Object[]&gt;</code>: An array of found entries with resolved relations.</li> </ul>"},{"location":"relation/#relation-types","title":"Relation Types","text":"<p>The <code>Relation</code> class supports the following relation types:</p> <ol> <li>One-to-One (<code>\"1\"</code>): Resolves a single related entry.</li> <li>One-to-Many (<code>\"1n\"</code>): Resolves multiple related entries.</li> <li>Many-to-Many (<code>\"nm\"</code>): Resolves all entries in the related collection.</li> <li>Legacy One-to-One (<code>\"11\"</code>): Similar to <code>\"1\"</code>, but internally performs a <code>findOne</code> operation for each document during a <code>find</code> query. This mode is less performant but might be useful in specific scenarios, such as with custom adapters or legacy systems. This is considered a legacy mode but is still fully supported.</li> </ol>"},{"location":"relation/#example-usage","title":"Example Usage","text":"<pre><code>import Relation from \"@wxn0brp/db\";\nimport { ValtheraAutoCreate } from \"@wxn0brp/db/autoCreate\";\n\n// Create database instances\nconst db1 = ValtheraAutoCreate(\"path/to/db1\");\nconst db2 = ValtheraAutoCreate(\"path/to/db2\");\n\n// Define databases\nconst dbs = {\n    db1,\n    db2\n};\n\n// Define relations\nconst relations = {\n    author: {\n        path: [\"db1\", \"users\"],\n        pk: \"authorId\",\n        fk: \"_id\",\n        type: \"1\",\n        select: [\"name\", \"email\"]\n    },\n    comments: {\n        path: [\"db2\", \"comments\"],\n        pk: \"_id\",\n        fk: \"postId\",\n        type: \"1n\",\n        select: [\"content\", \"createdAt\"]\n    }\n};\n\n// Create a Relation instance\nconst relation = new Relation(dbs);\n\n// Find a single post with relations\nconst post = await relation.findOne(\n    [\"db1\", \"posts\"],\n    { _id: \"post123\" },\n    relations,\n    [[\"title\"], [\"author.name\"], [\"comments.content\"]]\n);\n\nconsole.log(post);\n\n// Find multiple posts with relations\nconst posts = await relation.find(\n    [\"db1\", \"posts\"],\n    { category: \"tech\" },\n    relations,\n    [[\"title\"], [\"author.name\"], [\"comments.content\"]],\n    { limit: 10 }\n);\n\nconsole.log(posts);\n</code></pre> <p>This example demonstrates how to use the <code>Relation</code> class to resolve relationships between collections in different databases.</p>"},{"location":"remote/","title":"Remote Valthera and Graph Valthera Client Documentation","text":""},{"location":"remote/#remote-object-structure","title":"<code>remote</code> Object Structure","text":"<ul> <li><code>name</code> (<code>string</code>): The name of the Valthera.</li> <li><code>url</code> (<code>string</code>): The URL of the remote Valthera.</li> <li><code>auth</code> (<code>string</code>): The authentication token for accessing the Valthera.</li> </ul>"},{"location":"remote/#class-valtheraremoteremote","title":"Class: <code>ValtheraRemote(remote)</code>","text":"<p><code>ValtheraRemote</code> is an extended version of the <code>Valthera</code> class, designed to handle API requests. It provides the same functionalities as <code>Valthera</code>, but enables remote communication, allowing you to interact with Valthera through HTTP requests.</p>"},{"location":"remote/#example-usage","title":"Example Usage","text":"<p><pre><code>const remoteDB = new ValtheraRemote({\n    name: 'myRemoteDB',\n    url: 'https://example.com/db',\n    auth: 'your-auth-token'\n});\n</code></pre> or <pre><code>const remoteDB = new ValtheraRemote('https://dbName:token@example.com/db');\n</code></pre></p>"},{"location":"remote/#class-graphremoteremote","title":"Class: <code>GraphRemote(remote)</code>","text":"<p><code>GraphRemote</code> is an extension of the <code>Graph</code> class, specifically designed for working with graph Valthera's over HTTP. It supports querying and modifying graph data, providing methods tailored for graph operations such as adding nodes, edges, and executing graph queries.</p> <p>These constructors provide flexibility in initializing remote connections for both standard and graph-based Valthera databases.</p>"},{"location":"search_opts/","title":"Predefined Search Options Quick Reference","text":""},{"location":"search_opts/#operators","title":"Operators","text":""},{"location":"search_opts/#logical-operators","title":"Logical Operators","text":""},{"location":"search_opts/#and","title":"$and","text":"<p>Checks if all conditions in an array are true. <pre><code>{\n  $and: [\n    { $gt: { age: 20 } },\n    { $exists: { name: true } }\n  ]\n}\n</code></pre></p>"},{"location":"search_opts/#or","title":"$or","text":"<p>Checks if at least one condition in an array is true. <pre><code>{\n  $or: [\n    { $lt: { age: 20 } },\n    { $gt: { age: 60 } }\n  ]\n}\n</code></pre></p>"},{"location":"search_opts/#not","title":"$not","text":"<p>Negates a condition. <pre><code>{\n  $not: { $type: { age: \"string\" } }\n}\n</code></pre></p>"},{"location":"search_opts/#comparison-operators","title":"Comparison Operators","text":""},{"location":"search_opts/#gt","title":"$gt","text":"<p>Greater than comparison. <pre><code>{ $gt: { age: 18 } }\n</code></pre></p>"},{"location":"search_opts/#lt","title":"$lt","text":"<p>Less than comparison. <pre><code>{ $lt: { score: 100 } }\n</code></pre></p>"},{"location":"search_opts/#gte","title":"$gte","text":"<p>Greater than or equal comparison. <pre><code>{ $gte: { price: 9.99 } }\n</code></pre></p>"},{"location":"search_opts/#lte","title":"$lte","text":"<p>Less than or equal comparison. <pre><code>{ $lte: { quantity: 50 } }\n</code></pre></p>"},{"location":"search_opts/#idgt","title":"$idGt","text":"<p>Greater than comparison for IDs (accepts <code>string</code> or <code>number</code>). <pre><code>{ $idGt: { _id: \"miblu25k-d-g\" } }\n</code></pre></p>"},{"location":"search_opts/#idlt","title":"$idLt","text":"<p>Less than comparison for IDs (accepts <code>string</code> or <code>number</code>). <pre><code>{ $idLt: { _id: \"miblu25k-d-g\" } }\n</code></pre></p>"},{"location":"search_opts/#idgte","title":"$idGte","text":"<p>Greater than or equal comparison for IDs (accepts <code>string</code> or <code>number</code>). <pre><code>{ $idGte: { _id: \"miblu25k-d-g\" } }\n</code></pre></p>"},{"location":"search_opts/#idlte","title":"$idLte","text":"<p>Less than or equal comparison for IDs (accepts <code>string</code> or <code>number</code>). <pre><code>{ $idLte: { _id: \"miblu25k-d-g\" } }\n</code></pre></p>"},{"location":"search_opts/#in","title":"$in","text":"<p>Checks if value is in an array. <pre><code>{ $in: { status: [\"active\", \"pending\"] } }\n</code></pre></p>"},{"location":"search_opts/#nin","title":"$nin","text":"<p>Checks if value is not in an array. <pre><code>{ $nin: { category: [\"archived\", \"deleted\"] } }\n</code></pre></p>"},{"location":"search_opts/#between","title":"$between","text":"<p>Checks if a number is between two values (inclusive). <pre><code>{ $between: { age: [18, 65] } }\n</code></pre></p>"},{"location":"search_opts/#type-and-existence-operators","title":"Type and Existence Operators","text":""},{"location":"search_opts/#exists","title":"$exists","text":"<p>Checks if a field exists (or doesn't exist). <pre><code>{ $exists: { email: true, deletedAt: false } }\n</code></pre></p>"},{"location":"search_opts/#type","title":"$type","text":"<p>Checks the type of a field. <pre><code>{ $type: { age: \"number\", name: \"string\" } }\n</code></pre></p>"},{"location":"search_opts/#array-operators","title":"Array Operators","text":""},{"location":"search_opts/#arrinc","title":"$arrinc","text":"<p>Checks if an array includes at least one of the specified values. <pre><code>{ $arrinc: { tags: [\"developer\", \"designer\"] } }\n</code></pre></p>"},{"location":"search_opts/#arrincall","title":"$arrincall","text":"<p>Checks if an array includes all of the specified values. <pre><code>{ $arrincall: { permissions: [\"read\", \"write\"] } }\n</code></pre></p>"},{"location":"search_opts/#size","title":"$size","text":"<p>Checks the length of an array or string. <pre><code>{ $size: { tags: 3 } }\n</code></pre></p>"},{"location":"search_opts/#string-operators","title":"String Operators","text":""},{"location":"search_opts/#regex","title":"$regex","text":"<p>Tests a string against a regular expression. <pre><code>{ $regex: { email: /^[^@]+@[^@]+\\.[^@]+$/ } }\n</code></pre></p>"},{"location":"search_opts/#startswith","title":"$startsWith","text":"<p>Checks if a string starts with a specified value. <pre><code>{ $startsWith: { name: \"Dr.\" } }\n</code></pre></p>"},{"location":"search_opts/#endswith","title":"$endsWith","text":"<p>Checks if a string ends with a specified value. <pre><code>{ $endsWith: { email: \"@example.com\" } }\n</code></pre></p>"},{"location":"search_opts/#other-operators","title":"Other Operators","text":""},{"location":"search_opts/#subset","title":"$subset","text":"<p>Allows for skipping advanced validation for specific fields, applying only basic validation. This is useful when validation data may conflict with predefined functions (starting with $), while user data might also contain similar keys. Use this operator as a compromise. <pre><code>{ $subset: { $lt: \"John Doe\" } } // check if \"$lt\" is \"John Doe\"\n</code></pre></p>"},{"location":"search_opts/#examples","title":"Examples","text":""},{"location":"search_opts/#complex-validation","title":"Complex Validation","text":"<pre><code>const criteria = {\n  $and: [\n    {\n      $or: [\n        { $gt: { age: 18 } },\n        { $exists: { guardianConsent: true } }\n      ]\n    },\n    {\n      $type: { email: \"string\" },\n      $regex: { email: /^[^@]+@[^@]+\\.[^@]+$/ }\n    },\n    {\n      $arrincall: { roles: [\"user\"] },\n      $not: { $in: { status: [\"banned\", \"suspended\"] } }\n    }\n  ]\n};\n\nconst user = {\n  age: 16,\n  guardianConsent: true,\n  email: \"john@example.com\",\n  roles: [\"user\", \"premium\"],\n  status: \"active\"\n};\n\nconst isValid = hasFieldsAdvanced(user, criteria); // true\n</code></pre>"},{"location":"search_opts/#nested-conditions","title":"Nested Conditions","text":"<pre><code>const criteria = {\n  $and: [\n    {\n      $exists: { address: true },\n      $type: { address: \"object\" }\n    },\n    {\n      $or: [\n        { $exists: { \"address.zipCode\": true } },\n        {\n          $and: [\n            { $exists: { \"address.city\": true } },\n            { $exists: { \"address.country\": true } }\n          ]\n        }\n      ]\n    }\n  ]\n};\n\nconst user = {\n  address: {\n    city: \"New York\",\n    country: \"USA\"\n  }\n};\n\nconst isValid = hasFieldsAdvanced(user, criteria); // true\n</code></pre>"},{"location":"search_opts/#error-handling","title":"Error Handling","text":"<p>The function will throw an error if: - The <code>fields</code> parameter is not an object - The <code>fields</code> parameter is null</p> <p>Always wrap the function call in a try-catch block when using with untrusted input:</p> <pre><code>try {\n  const isValid = hasFieldsAdvanced(obj, criteria);\n  // Handle result\n} catch (error) {\n  // Handle error\n  console.error('Validation error:', error.message);\n}\n</code></pre>"},{"location":"updater/","title":"Predefined Update Options Quick Reference","text":""},{"location":"updater/#arrays","title":"Arrays","text":""},{"location":"updater/#push","title":"<code>$push</code>","text":"<p>Adds an element to the end of an array.</p> <pre><code>{\n    $push: { tags: \"designer\" }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    tags: [\"developer\"]\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    tags: [\"developer\", \"designer\"]\n}\n</code></pre>"},{"location":"updater/#pushset","title":"<code>$pushset</code>","text":"<p>Adds an element to the end of an array and removes duplicates.</p> <pre><code>{\n    $pushset: { tags: \"designer\" }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    tags: [\"developer\", \"designer\", \"developer\"]\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    tags: [\"developer\", \"designer\"]\n}\n</code></pre>"},{"location":"updater/#pull","title":"<code>$pull</code>","text":"<p>Removes a specific element from an array.</p> <pre><code>{\n    $pull: { tags: \"developer\" }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    tags: [\"developer\", \"designer\"]\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    tags: [\"designer\"]\n}\n</code></pre>"},{"location":"updater/#pullall","title":"<code>$pullall</code>","text":"<p>Removes all occurrences of specified elements from an array.</p> <pre><code>{\n    $pullall: { tags: [\"developer\", \"designer\"] }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    tags: [\"developer\", \"designer\", \"manager\"]\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    tags: [\"manager\"]\n}\n</code></pre>"},{"location":"updater/#numbers","title":"Numbers","text":""},{"location":"updater/#inc","title":"<code>$inc</code>","text":"<p>Increments a numeric value by a given amount.</p> <pre><code>{\n    $inc: { counter: 1 }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    counter: 5\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    counter: 6\n}\n</code></pre>"},{"location":"updater/#dec","title":"<code>$dec</code>","text":"<p>Decrements a numeric value by a given amount.</p> <pre><code>{\n    $dec: { counter: 1 }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    counter: 5\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    counter: 4\n}\n</code></pre>"},{"location":"updater/#objects","title":"Objects","text":""},{"location":"updater/#merge","title":"<code>$merge</code>","text":"<p>Merges a nested object, adding or updating properties.</p> <pre><code>{\n    $merge: { settings: { theme: \"dark\" } }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    settings: { theme: \"light\", language: \"en\" }\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    settings: { theme: \"dark\", language: \"en\" }\n}\n</code></pre>"},{"location":"updater/#deepmerge","title":"<code>$deepMerge</code>","text":"<p>Deeply merges nested objects, adding or updating properties recursively.</p> <pre><code>{\n    $deepMerge: {\n        user: {\n            address: {\n                city: \"New York\"\n            }\n        }\n    }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    user: {\n        name: \"John\",\n        address: {\n            street: \"123 Main St\",\n            city: \"San Francisco\"\n        }\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    user: {\n        name: \"John\",\n        address: {\n            street: \"123 Main St\",\n            city: \"New York\"\n        }\n    }\n}\n</code></pre>"},{"location":"updater/#others","title":"Others","text":""},{"location":"updater/#unset","title":"<code>$unset</code>","text":"<p>Removes a specified key from an object.</p> <pre><code>{\n    $unset: { age: true }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    name: \"John\",\n    age: 30\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    name: \"John\"\n}\n</code></pre>"},{"location":"updater/#rename","title":"<code>$rename</code>","text":"<p>Renames a key in an object.</p> <pre><code>{\n    $rename: { firstName: \"name\" }\n}\n</code></pre> <p>Input:</p> <pre><code>{\n    firstName: \"John\",\n    lastName: \"Doe\"\n}\n</code></pre> <p>Output:</p> <pre><code>{\n    name: \"John\",\n    lastName: \"Doe\"\n}\n</code></pre>"},{"location":"valthera/","title":"ValtheraDB Documentation","text":""},{"location":"valthera/#class-valthera","title":"Class: <code>Valthera</code>","text":""},{"location":"valthera/#async-getcollections","title":"<code>async getCollections()</code>","text":"<p>Gets the names of all available collections in the database.</p> <ul> <li>Returns:</li> <li><code>Promise&lt;string[]&gt;</code>: A promise that resolves with an array of collection names.</li> </ul>"},{"location":"valthera/#async-ensurecollectioncollection","title":"<code>async ensureCollection(collection)</code>","text":"<p>Checks and creates the specified collection if it doesn't exist.</p> <ul> <li>Parameters:</li> <li> <p><code>collection</code> (<code>string</code>): The name of the collection to check.</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;boolean&gt;</code>: A promise that resolves to <code>true</code> if the collection was created or already exists.</li> </ul>"},{"location":"valthera/#async-issetcollectioncollection","title":"<code>async issetCollection(collection)</code>","text":"<p>Checks if a collection exists.</p> <ul> <li>Parameters:</li> <li><code>collection</code> (<code>string</code>): The name of the collection.</li> <li>Returns:</li> <li><code>Promise&lt;boolean&gt;</code>: A promise that resolves to <code>true</code> if the collection exists, otherwise <code>false</code>.</li> </ul>"},{"location":"valthera/#async-removecollectioncollection","title":"<code>async removeCollection(collection)</code>","text":"<p>Removes the specified collection from the Valthera file system.</p> <ul> <li>Parameters:</li> <li> <p><code>collection</code> (<code>string</code>): The name of the collection to remove.</p> </li> <li> <p>Returns:</p> </li> <li><code>Promise&lt;boolean&gt;</code>: A promise that resolves when the collection is removed.</li> </ul>"}]}